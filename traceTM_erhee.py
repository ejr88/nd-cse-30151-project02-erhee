# -*- coding: utf-8 -*-
"""traceTM_erhee.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12gzvfuHfuxr8hwteMhevwEiPymaPaLAE
"""

# PROJECT 02 - erhee
import os
import csv
from collections import deque
from tabulate import tabulate

class NTM:
    def __init__(self, transitions, start_state, accept_states, reject_states, blank="_"):
        """
        Initialize the NTM.
        :param transitions: Dictionary representing state transitions.
        :param start_state: Initial state.
        :param accept_states: List of accepting states.
        :param reject_states: List of rejecting states.
        :param blank: The blank symbol for the tape.
        """
        self.transitions = transitions
        self.start_state = start_state
        self.accept_states = accept_states
        self.reject_states = reject_states
        self.blank = blank

class Tape: # to keep track of the string and the position you are at
    def __init__(self, state, head_position, left = [], right = []):
        self.state = state
        self.head_position = head_position
        self.left = left
        self.right = right

def bfs_ntm_trace(ntm, input_string, max_depth):
    steps = 0
    avg_nondet = 1 # to measure non determinism
    accept = False
    string = list(input_string)
    tape = Tape(state = ntm.start_state, head_position = string[0], right = string[1:])
    final_paths = []

    # BFS queue
    visited = dict()
    queue = deque([(tape, 0, [tape])]) # configuration

    while queue and steps < max_depth:
        current_conf, depth, path = queue.popleft()

        if depth not in visited:
            visited[depth] = []
        visited[depth].append(tape)

        # Stop conditions
        if current_conf.state in ntm.accept_states:
            accept = True
            break
        if current_conf.state in ntm.reject_states:
            continue

        # perform transitions
        head = current_conf.head_position # initialize the head position to be tracked
        new_tape_list = [] # keep track of all new tapes from the transitions

        new_tape = current_conf
        if current_conf.state in ntm.transitions:
          for transition in ntm.transitions[current_conf.state]: # head position will update throughout current state
              # Unpack transition details
              current_symbol, new_state, write_symbol, move = transition
              head = write_symbol # initialize temp variables
              right = current_conf.right
              left = current_conf.left

              if move == 'R':
                  if len(current_conf.right) == 0: # if the right list is empty, give it the blank symbol
                      right = [ntm.blank]
                  left = current_conf.left + [head] # add new head position to end of left side of string
                  new_tape = Tape(state = new_state, head_position = head, left = left, right = right[1:])
              elif move == 'L':
                  if len(current_conf.left) == 0: # if the left list is empty, give it the blank symbol
                      left = [ntm.blank]
                  right = [head] + current_conf.right # add new head to front of right list because it is before the rest of the string
                  new_tape = Tape(state = new_state, head_position = head, left = left[:-1], right = right)

              new_tape_list.append(new_tape) # add each new tape to the list

        # once transitions have been performed, add the new tapes to the queue to be checked
        for new_tape in new_tape_list:
            depth = depth + 1
            queue.append((new_tape, depth, path + [new_tape]))

        steps += 1 # increase number of transitions after going through an entire level

    for tape in path:
        string_tape = tape.state + ', ' + ''.join(tape.left) + ', ' + tape.head_position + ', ' + ''.join(tape.right)
        final_paths.append(string_tape)

    return accept, steps, final_paths, max(visited.keys())
    # return accept status, total transitions, the path, and visited depth

# --------------------------------------------------------------------------------------------------------------------

# MAIN FUNCTION
start = ""
accept_states_list = []
reject_states_list = []
transitions = dict() # dictionary where the state has an associated list of transitions
lines = 1 # flag to count lines in csv file to determine if it is accept state or reject state

with open('a_plus.csv', 'r') as file: # open csv file name
    csv_reader = csv.reader(file)
    name = next(csv_reader) # get the name of the machine
    for row in csv_reader:
        lines += 1
        if lines == 5: # get the start state
            start = row[0]
            continue
        if lines == 6: # get the accept states
            accept_states_list.append(row[0])
            continue
        if lines == 7: # get the reject states
            reject_states_list.append(row[0])
        if lines >= 8: # get the transitions
            if transitions.get(row[0]) == None:
                transitions[row[0]] = [] # create a list to append to
            transitions[row[0]].append((row[1], row[2], row[3], row[4]))

# Create NTM instance
ntm = NTM(
    transitions=transitions,
    start_state=start,
    accept_states=accept_states_list,
    reject_states=reject_states_list
)

input_string = input("Enter string: ")
max_depth = int(input("Enter max depth: "))

# call the ntm function
status, total_transitions, path, result = bfs_ntm_trace(ntm, input_string, max_depth)
#print(name[0]) # echo name of machine
#print(input_string) # echo the initial inputted string
if status == True:
    end_status = "Accept."
else:
    end_status = "Rejected."

full_path = ""
for i in path:
    full_path += i + "\n"

avg_nondet = total_transitions / result # configurations / depth
# write to output file
output_file = "output2.txt"
with open(output_file, "w") as file:
  file.write(tabulate([[name[0], input_string, end_status, result, total_transitions, avg_nondet, full_path]],
               headers=['Name', 'Input String', 'Result', 'Depth', 'Number of configurations', 'Average nondeterminism', 'Paths']))

print(tabulate([[name[0], input_string, end_status, result, total_transitions, avg_nondet, full_path]],
               headers=['Name', 'Input String', 'Result', 'Depth', 'Number of configurations', 'Average nondeterminism', 'Paths']))